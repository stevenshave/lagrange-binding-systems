from inspect import signature

class LagrangeBindingSystemFactory():
    species_order = []
    custom_function_name = ""
    custom_function_arguments=[]
    products = {}
    fundamental_species = []
    constrains = []
    kds = []
    binding_function = None
    binding_function_string = None
    default_readout=None
    

    def _reorder(self, input_array):
        out = []
        for item in self.species_order:
            if item in input_array:
                out.append(item)
        return out

    def _get_fundamental_concs(self):
        funamental_concs = []
        for i, f in enumerate(self.fundamental_species):
            funamental_concs.append(f"\t\t{f}=X[{i}]\n")
        return funamental_concs

    def _parse_reaction(self, line):
        line = line.lower()
        plus_pos = line.find("+")
        leftarrow_pos = line.find("<")
        rightarrow_pos = line.find(">")
        assert not (plus_pos == -1 or leftarrow_pos == -1 or rightarrow_pos == -
                    1), f"{line} is malfomred, needs the form P+L<->PL"
        return [line[:plus_pos].strip(), line[plus_pos+1:leftarrow_pos].strip(), line[rightarrow_pos+1:].strip()]

    def __init__(self, system_string):
        lines = [x.strip().split("#")[0].strip()
                 for x in system_string.splitlines() if len(x) > 0 and x[0] != "#"]
        if lines[0].find("+") >= 0:
            self.custom_function_name = "autogenerated_lagrange_function"
        else:
            self.custom_function_name = lines[0]
        lines = lines[1:]
        for line in lines:
            s1, s2, p = self._parse_reaction(line)
            if p not in self.products.keys():
                self.products[p] = []
            if not s1 in self.species_order:
                self.species_order.append(s1)
            if not s2 in self.species_order:
                self.species_order.append(s2)
            if not p in self.species_order:
                self.species_order.append(p)
            self.products[p].append((s1, s2))
        self.fundamental_species = self._reorder(set([item for values in self.products.values(
        ) for items in values for item in items])-self.products.keys())
        self.kds = set([f"kd_{t[0]}_{t[1]}" for u in [self.products[p]
                                                      for p in self._reorder(self.products.keys())] for t in u])
        assert len(
            self.fundamental_species) > 0, "Malformed system, no fundamental species"
        assert len(self.products.keys()) > 0, "Malformed species, no products"
        self.binding_function_string = self._get_func_as_string()
        exec(self.binding_function_string, globals())
        self.binding_function=eval(self.custom_function_name)
        self.custom_function_arguments=list(signature(self.binding_function).parameters.keys())

    def _get_constraints(self):
        constraints = []
        for species_i, species in enumerate(self.fundamental_species):
            tmpstring = f"\t\tconstraint{species_i+1}={species}0-({species}+"
            species_found_in_count = {sk: sum(
                (r[0] == species, r[1] == species)) for sk in self.products.keys() for r in self.products[sk]}
            tmpstring += "+".join(
                [f"{species_found_in_count[p]}*{p}" for p in species_found_in_count if species_found_in_count[p] > 0])
            tmpstring += ")\n"
            constraints.append(tmpstring)
        n_constrains = len(constraints)
        tmpstring = "\t\tnonzero_constraint="
        constraints.append("\t\tnonzero_constraint="+"+".join(
            [f"(constraint{i+1}-abs(constraint{i+1}))" for i in range(len(constraints))])+"\n")
        return constraints

    def _get_mass_balances(self):
        mass_balances = []
        for prod in self.products.keys():
            line = f"\t\t{prod}=("
            tmpstrings = []
            # Write out product=species1*species2/kd further complicated when multiple ways exist to make the species.
            # Write speciesn*species part, dealing with addition of multiple ways to make it
            for t in self.products[prod]:
                tmpstrings.append(f"{t[0]}*{t[1]}")
            line += "+".join(tmpstrings)+f")/("
            # Write out the KD sections
            tmpstrings = []
            for t in self.products[prod]:
                tmpstrings.append("kd_"+t[0]+"_"+t[1])
            line += (f"{'+'.join(tmpstrings)})\n")
            mass_balances.append(line)
        return mass_balances

    def _get_return_statement(self):
        return_statements = []
        return_statements.append("\t\treturn "+self.species_order[-1])
        return_statements += [f"X[{i+len(self.fundamental_species)}]*constraint{i+1}" for i in range(
            len(self.fundamental_species))]
        return_statements.append(
            f"X[{len(self.fundamental_species)+len(self.fundamental_species)}]*nonzero_constraint")
        return_statements[-1] = return_statements[-1]+"\n"
        return return_statements

    def write_custom_lagrange_function(self, output_file_name):
        assert self.binding_function_string is not None, "binding_function_string not generated"
        out = open(output_file_name, "w")
        out.write(self.binding_function_string)
        out.close()

    def _get_func_as_string(self):
        custom_lagrange_definition = '\"\"\"\nCustom generated binding system\n\nLagrane multiplier binding system genetated with generated with \nhttps://github.com/stevenshave/lagrange-binding-systems/write_custom_system.py\"\"\"\n\n'
        custom_lagrange_definition += f'from scipy.optimize import fsolve\nfrom autograd import grad\ndef {self.custom_function_name}('
        custom_lagrange_definition += ", ".join(
            [x+"0" for x in self.fundamental_species])+", "+", ".join(self.kds)+"):\n"
        custom_lagrange_definition += "\tdef F(X): # Augmented Lagrange function\n"
        custom_lagrange_definition += "".join(self._get_fundamental_concs())
        custom_lagrange_definition += "".join(self._get_mass_balances())
        custom_lagrange_definition += "".join(self._get_constraints())
        custom_lagrange_definition += "+".join(self._get_return_statement())
        custom_lagrange_definition += "\tderivative_function = grad(F) # Gradients of the Lagrange function\n"
        custom_lagrange_definition += "\t"+", ".join([f"{s}" for s in self.fundamental_species])+", "+", ".join([f"lam{x}" for x in range(len(self.fundamental_species)+1)]) + \
            " = fsolve(derivative_function, ["+", ".join([x+"0" for x in self.fundamental_species]) + \
            ", " + \
            ", ".join(["1.0" for x in range(
                len(self.fundamental_species)+1)])+"])\n"
        custom_lagrange_definition += "\treturn {"+", ".join([f"'{s}':{s}" for s in self.fundamental_species])+", "+", ".join(
            [mb.replace("\t\t", "'").replace("\n", "").replace("=", "':") for mb in self._get_mass_balances()])+"}\n"
        return custom_lagrange_definition


if __name__ == "__main__":
    custom_system_definition_string = """
custom_system
P+L<->PL
P+P<->PP
#PL1+L<->PL12
#PL2+L<->PL12
"""
    new_lagrange = LagrangeBindingSystemFactory(
        custom_system_definition_string)
    print(new_lagrange.binding_function(10,10,10,10))
    new_lagrange.write_custom_lagrange_function("tmp_example_output.py")